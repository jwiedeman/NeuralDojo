
<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>d/dx f(g(x)) = f'(g(x))·g'(x)</title>

        <!-- Favicon -->
        <link rel="icon" type="image/png" href="images/sgd.png" />

        <!-- Open Graph / Social Media Preview -->
        <meta property="og:title" content="Built, or grown?" />
        <meta property="og:description" content="No, it wasn't… we designed the learning algorithm… But we don't really understand exactly how they do those things." />
        <meta property="og:image" content="images/sgd.png" />
        <meta property="og:image:type" content="image/png" />
        <meta name="twitter:card" content="summary_large_image" />
        <meta name="twitter:title" content="Built, or grown?" />
        <meta name="twitter:description" content="No, it wasn't… we designed the learning algorithm… But we don't really understand exactly how they do those things." />
        <meta name="twitter:image" content="images/sgd.png" />
        <style>
            @font-face {
                font-family: 'Berkeley Mono';
                src: url('fonts/BerkeleyMono-Regular.woff2') format('woff2');
                font-weight: 400;
                font-style: normal;
            }

            @font-face {
                font-family: 'Berkeley Mono';
                src: url('fonts/BerkeleyMono-Bold.woff2') format('woff2');
                font-weight: 700;
                font-style: normal;
            }

            * {
                margin: 0;
                padding: 0;
                box-sizing: border-box;
            }

            body {
                font-family: 'Berkeley Mono', monospace;
                background: #f5f5f5;
                color: #000;
                padding: 20px;
                line-height: 1.5;
                font-size: 14px;
                overflow-x: hidden;
            }

            .container {
                max-width: 1400px;
                margin: 0 auto;
                border: 3px solid #000;
                overflow-x: hidden;
            }

            .main-content {
                display: grid;
                grid-template-columns: 5fr 2fr;
                gap: 0;
            }

            .visualization {
                background: #fff;
                padding: 30px;
                border-right: 3px solid #000;
            }

            canvas {
                width: 100%;
                border: 3px solid #000;
                background: #fff;
            }

            #patternCanvas {
                height: auto;
            }

            .controls {
                background: #fff;
                padding: 30px;
            }

            .control-group {
                margin-bottom: 20px;
                padding-bottom: 20px;
                border-bottom: 2px dotted #000;
            }

            .control-group label {
                display: block;
                color: #000;
                margin-bottom: 8px;
                font-size: 13px;
                font-weight: bold;
                text-transform: uppercase;
                letter-spacing: 1px;
            }

            .control-group input[type="range"] {
                width: 100%;
                margin-bottom: 8px;
            }

            .control-group .value {
                color: #000;
                font-size: 13px;
            }

            input[type="text"] {
                width: 100%;
                padding: 10px;
                border: 2px solid #000;
                font-family: 'Berkeley Mono', monospace;
                font-size: 12px;
                background: #fff;
                margin-bottom: 10px;
            }

            input[type="text"]:focus {
                outline: none;
                border-color: #000;
                background: #f5f5f5;
            }

            input[type="text"]::placeholder {
                color: #888;
            }

            button {
                width: 100%;
                padding: 12px;
                margin-bottom: 8px;
                background: #fff;
                color: #000;
                border: 3px solid #000;
                font-family: 'Berkeley Mono', monospace;
                font-size: 14px;
                font-weight: bold;
                cursor: pointer;
                text-transform: uppercase;
                letter-spacing: 1px;
            }

            button:hover {
                background: #000;
                color: #fff;
            }

            button.secondary {
                background: #fff;
                color: #000;
                border: 1px solid #000;
            }

            button.secondary:hover {
                background: #000;
                color: #fff;
            }

            .algorithm-box {
                background: #fff;
                padding: 20px;
                border: 3px solid #000;
                margin-bottom: 20px;
            }

            .algorithm-box h3 {
                color: #000;
                margin-bottom: 12px;
                font-size: 14px;
                font-weight: bold;
                text-transform: uppercase;
                letter-spacing: 1px;
            }

            .algorithm-box code {
                display: block;
                color: #000;
                font-size: 13px;
                line-height: 1.6;
                white-space: pre;
            }

            .stats {
                background: #fff;
                padding: 20px;
                border: 3px solid #000;
                margin-top: 20px;
            }

            .stats div {
                margin-bottom: 8px;
                font-size: 13px;
            }

            .stats .label {
                color: #000;
                display: inline-block;
                width: 100px;
                font-weight: bold;
            }

            .draw-interface {
                background: #fff;
                padding: 20px;
                border: 3px solid #000;
                margin-top: 20px;
            }

            .draw-interface h4 {
                color: #000;
                margin-bottom: 12px;
                font-size: 14px;
                font-weight: bold;
                text-transform: uppercase;
            }

            .draw-canvas {
                display: grid;
                grid-template-columns: repeat(8, 1fr);
                gap: 1px;
                width: 320px;
                margin-bottom: 12px;
                cursor: crosshair;
                user-select: none;
                border: 3px solid #000;
            }

            .draw-pixel {
                aspect-ratio: 1;
                background: #fff;
                border: 1px solid #000;
            }

            .draw-pixel.active {
                background: #000;
            }

            .draw-controls {
                display: flex;
                gap: 8px;
                margin-bottom: 12px;
            }

            .draw-controls button {
                flex: 1;
                padding: 10px;
                font-size: 13px;
            }

            .prediction {
                font-size: 14px;
                color: #000;
                margin-top: 12px;
                font-weight: bold;
            }

            .explanation {
                background: #fff;
                padding: 30px;
                border-bottom: 3px solid #000;
                font-family: -apple-system, system-ui, BlinkMacSystemFont, 'Segoe UI', Roboto;
            }

            .explanation h2 {
                color: #000;
                margin-bottom: 15px;
                font-size: 18px;
                font-weight: bold;
                text-transform: uppercase;
                border-bottom: 2px dotted #000;
                padding-bottom: 8px;
            }

            .explanation p {
                margin-bottom: 15px;
                color: #000;
                font-size: 14px;
                line-height: 1.6;
            }

            .explanation strong {
                color: #000;
                font-weight: bold;
            }

            .weights-display {
                margin-top: 20px;
                padding-top: 20px;
                border-top: 2px dotted #000;
            }

            .class-gallery {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(110px, 1fr));
                gap: 12px;
                margin-bottom: 20px;
            }

            .class-card {
                background: #fff;
                border: 3px solid #000;
                padding: 10px;
                display: flex;
                flex-direction: column;
                align-items: center;
                gap: 8px;
                text-align: center;
            }

            .class-card h4 {
                font-size: 11px;
                letter-spacing: 1px;
                color: #000;
            }

            .class-preview-grid {
                display: grid;
                grid-template-columns: repeat(8, 1fr);
                width: 80px;
                height: 80px;
                border: 3px solid #000;
                background: #fff;
            }

            .class-preview-grid div,
            .pattern-preview-grid div {
                border: 1px solid #000;
                background: #fff;
            }

            .class-preview-grid div.filled,
            .pattern-preview-grid div.filled {
                background: #000;
            }

            .class-preview-grid div.changed,
            .pattern-preview-grid div.changed {
                outline: 2px solid #f97316;
            }

            .dataset-builder {
                background: #fff;
                border: 3px solid #000;
                padding: 20px;
                margin-bottom: 20px;
            }

            .dataset-builder h3 {
                color: #000;
                font-size: 14px;
                font-weight: bold;
                text-transform: uppercase;
                margin-bottom: 10px;
            }

            .dataset-builder p {
                font-size: 12px;
                line-height: 1.5;
                color: #000;
                margin-bottom: 15px;
            }

            .pattern-family-list {
                display: flex;
                flex-direction: column;
                gap: 12px;
                margin-bottom: 15px;
            }

            .pattern-family {
                border: 2px dotted #000;
                padding: 12px;
                background: #fdfdfd;
                display: flex;
                flex-direction: column;
                gap: 10px;
            }

            .pattern-family.disabled {
                opacity: 0.6;
            }

            .pattern-family-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                gap: 10px;
            }

            .pattern-family-header label {
                font-size: 12px;
                font-weight: bold;
                letter-spacing: 0.5px;
                display: flex;
                align-items: center;
                gap: 6px;
            }

            .pattern-family-body {
                display: flex;
                gap: 12px;
                align-items: center;
            }

            .pattern-controls {
                flex: 1;
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
                gap: 10px;
                font-size: 11px;
            }

            .pattern-controls label {
                display: block;
                color: #000;
                font-weight: bold;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                margin-bottom: 4px;
            }

            .pattern-controls .value {
                font-weight: normal;
                display: block;
                margin-top: 4px;
            }

            .pattern-preview-grid.small {
                width: 64px;
                height: 64px;
            }

            .pattern-preview-grid {
                display: grid;
                grid-template-columns: repeat(8, 1fr);
                border: 3px solid #000;
                background: #fff;
            }

            .pattern-preview-grid div {
                border: 1px solid #000;
                background: #fff;
            }

            .dataset-builder button.small {
                font-size: 12px;
                padding: 8px;
            }

            .dataset-builder button.tiny {
                font-size: 11px;
                padding: 6px 8px;
            }

            .custom-builder {
                display: flex;
                flex-direction: column;
                gap: 15px;
            }

            .custom-builder-grid {
                display: flex;
                gap: 20px;
                align-items: flex-start;
                flex-wrap: wrap;
            }

            .custom-builder-canvas {
                display: flex;
                flex-direction: column;
                gap: 10px;
                flex-shrink: 0;
            }

            .custom-builder-actions {
                display: flex;
                gap: 8px;
                flex-wrap: wrap;
            }

            .custom-builder-config {
                flex: 1;
                min-width: 220px;
                display: flex;
                flex-direction: column;
                gap: 12px;
            }

            .custom-builder-config label {
                font-size: 11px;
                font-weight: bold;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                color: #000;
            }

            .custom-builder-slider {
                display: flex;
                flex-direction: column;
                gap: 4px;
            }

            .custom-builder-slider .value {
                font-size: 11px;
                color: #000;
            }

            .custom-variant-list {
                display: flex;
                flex-wrap: wrap;
                gap: 10px;
            }

            .custom-variant {
                display: flex;
                flex-direction: column;
                gap: 6px;
                align-items: center;
            }

            .builder-message {
                font-size: 11px;
                color: #444;
                min-height: 14px;
            }

            .builder-message.error {
                color: #c53030;
            }

            .builder-message.success {
                color: #1a7f37;
            }

            .pattern-family-header button.remove-family {
                flex-shrink: 0;
            }


            .network-diagram {
                margin-top: 20px;
                padding: 20px;
                background: #fff;
                border: 3px solid #000;
            }

            .network-diagram h3 {
                color: #000;
                margin-bottom: 12px;
                font-size: 14px;
                font-weight: bold;
                text-transform: uppercase;
                text-align: left;
            }

            .network-viz {
                display: flex;
                justify-content: space-around;
                align-items: center;
                gap: 20px;
                margin-top: 20px;
            }

            .layer {
                display: flex;
                flex-direction: column;
                align-items: center;
                gap: 5px;
            }

            .layer-label {
                font-size: 11px;
                color: #000;
                margin-bottom: 5px;
                text-align: center;
                font-weight: bold;
            }

            .layer-nodes {
                display: flex;
                flex-direction: column;
                gap: 3px;
            }

            .node {
                width: 10px;
                height: 10px;
                background: #fff;
                border: 2px solid #000;
            }

            .node.hidden {
                background: #000;
            }

            .node.output {
                background: #fff;
                border: 2px solid #000;
            }

            .arrow {
                color: #000;
                font-size: 18px;
            }

            h3 {
                font-size: 14px;
                font-weight: bold;
                text-transform: uppercase;
                color: #000;
            }

            @media (max-width: 768px) {
                body {
                    padding: 10px;
                }

                .container {
                    border-width: 2px;
                }

                .explanation {
                    padding: 15px;
                }

                .visualization {
                    padding: 15px;
                    border-right: none;
                    border-bottom: 2px solid #000;
                }

                .controls {
                    padding: 15px;
                }

                .main-content {
                    grid-template-columns: 1fr;
                    display: flex;
                    flex-direction: column;
                }

                /* Flatten structure with display: contents */
                .visualization {
                    display: contents;
                }

                .controls {
                    display: contents;
                }

                /* Order all children directly */
                .visualization > div:first-child {
                    order: 1; /* Classification task */
                    padding: 15px;
                    background: #fff;
                    margin-bottom: 2px;
                }

                .visualization > canvas {
                    order: 2; /* Pattern canvas */
                    padding: 15px;
                    background: #fff;
                    margin-bottom: 2px;
                }

                .visualization .weights-display {
                    order: 3; /* Weights */
                    padding: 15px;
                    background: #fff;
                    margin-bottom: 2px;
                    border-top: none;
                }

                .controls .stats {
                    order: 4;
                    padding: 15px;
                    background: #fff;
                    border: none;
                    margin: 0 0 2px 0;
                }

                .controls .algorithm-box {
                    order: 5;
                    background: #fff;
                    padding: 15px;
                    margin-bottom: 2px;
                    border: none;
                }

                .controls .control-group {
                    order: 6;
                    background: #fff;
                    padding: 15px;
                    margin: 0 0 2px 0;
                    border-bottom: none;
                }

                .controls button {
                    order: 7;
                    background: #fff !important;
                    color: #000 !important;
                    padding: 12px;
                    margin-bottom: 2px;
                }

                button:hover {
                    background: #fff !important;
                    color: #000 !important;
                }

                button:active {
                    background: #f0f0f0 !important;
                    color: #000 !important;
                }

                .visualization .draw-interface {
                    order: 8; /* Last */
                    padding: 15px;
                    background: #fff;
                    margin: 0;
                    border: none;
                }

                .network-diagram {
                    display: none;
                }

                .network-viz {
                    flex-direction: column;
                    gap: 10px;
                }

                .arrow {
                    transform: rotate(90deg);
                }

                .draw-canvas {
                    width: 100%;
                    max-width: none;
                }

                .draw-interface > div[style*="display: flex"] {
                    flex-direction: column !important;
                }

                .draw-interface > div[style*="display: flex"] > div {
                    flex-shrink: 1 !important;
                    width: 100% !important;
                }

                .algorithm-box {
                    padding: 15px;
                    overflow-x: auto;
                }

                .algorithm-box code {
                    font-size: 11px;
                }

                .stats {
                    padding: 15px;
                }

                .draw-interface {
                    padding: 15px;
                }

                canvas {
                    max-width: 100%;
                }

                #patternCanvas {
                    width: 100% !important;
                }

                .weights-display {
                    overflow-x: hidden;
                }

                /* Classification task grid - 2x2 on mobile */
                .visualization > div > div[style*="grid-template-columns: repeat(4, 1fr)"] {
                    grid-template-columns: repeat(2, 1fr) !important;
                }
                .pattern-family-body {
                    flex-direction: column;
                    align-items: flex-start;
                }
                .pattern-family .pattern-preview-grid {
                    margin-bottom: 10px;
                }
                .pattern-controls {
                    grid-template-columns: 1fr !important;
                    width: 100%;
                }
                .dataset-builder {
                    margin-bottom: 15px;
                }
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div class="explanation">
                <div style="display: flex; justify-content: space-between; align-items: baseline; margin-bottom: 15px; border-bottom: 2px dotted #000; padding-bottom: 8px;">
                    <h2 style="margin: 0; border: none; padding: 0;">Growing a Neural Network</h2>
                    <div style="font-size: 14px; color: #666; font-family: 'Berkeley Mono', monospace;">d/dx f(g(x)) = f'(g(x))·g'(x)</div>
                </div>

                <p>
                    <strong>What we know:</strong> The exact update rule. At
                    every single step, we know precisely what will happen:
                    compute the gradient, multiply by learning rate, subtract
                    from parameters.
                </p>
                <p>
                    <strong>What we don't know:</strong> How the program that results from repeatedly applying the update rule works internally.
                </p>
                <p>
                    A tiny neural network learns to classify pixel patterns.
                    Watch the weights visualization evolve. These
                    weight patterns emerge from nothing but gradient descent. You
                    didn't design them. They're emergent.
                </p>
                <p>
                    The floating-point numbers in those weights
                    <em>are executable code</em>—a program that successfully
                    classifies patterns. But the program is inscrutable. It
                    works, we just don't automatically understand how. Hit "RESET NETWORK" and
                    watch completely different weights emerge. Same algorithm,
                    different solution every time.
                </p>
                <p>
                    <strong>Why this matters:</strong> This is the essence of
                    modern AI. We design the optimization process, not the
                    system itself. We understand the principle (minimize loss via
                    gradient descent), but cannot predict what features,
                    representations, or behaviors will emerge from billions of
                    these simple steps. GPT-4 is just this, scaled up.
                </p>

                <p><strong>Modern AI systems are grown, not built.</strong></p>

                <div style="background: #f5f5f5; border: 3px solid #000; padding: 25px; margin-top: 25px;">
                    <p style="font-size: 16px; line-height: 1.7; margin: 0;">
                        <strong>"We have a very good idea of sort of roughly what it's doing. But as soon as it gets really complicated, we don't actually know what's going on any more than we know what's going on in your brain."</strong>
                    </p>
                    <p style="font-size: 16px; line-height: 1.7; margin-top: 15px; margin-bottom: 15px;">
                        <em>60 Minutes (Pelley: "What do you mean we don't know exactly how it works? It was designed by people.")</em><br>
                        <strong>"No, it wasn't… we designed the learning algorithm… But we don't really understand exactly how they do those things."</strong>
                    </p>
                    <p style="font-size: 13px; margin: 0;">
                        — Geoffrey Hinton, <a href="https://www.youtube.com/watch?v=qrvK_KuIeJk&t=4m46s" target="_blank" style="color: #000; text-decoration: underline;">60 Minutes Interview</a>
                    </p>
                </div>
            </div>

            <div class="main-content">
                <div class="visualization">
                    <div
                        style="
                            background: #fff;
                            padding: 20px;
                            border: 3px solid #000;
                            margin-bottom: 20px;
                        "
                    >
                        <h3
                            style="
                                color: #000;
                                margin-bottom: 12px;
                                font-size: 14px;
                                font-weight: bold;
                                text-transform: uppercase;
                                border-bottom: 2px dotted #000;
                                padding-bottom: 8px;
                            "
                        >
                            CLASSIFICATION TASK
                        </h3>
                        <p
                            style="
                                font-size: 13px;
                                color: #000;
                                margin-bottom: 12px;
                                line-height: 1.5;
                            "
                        >
                            OBJECTIVE: Classify 8×8 pixel patterns into
                            <span id="classCountText">4</span> categories.
                            <span id="sampleCountText">300</span> training
                            samples total.
                        </p>
                        <div id="classGallery" class="class-gallery"></div>
                    </div>
                    <canvas id="patternCanvas"></canvas>

                    <div class="weights-display">
                        <h3
                            style="
                                color: #000;
                                margin-bottom: 12px;
                                font-size: 14px;
                                font-weight: bold;
                                text-transform: uppercase;
                            "
                        >
                            ALL NETWORK WEIGHTS
                        </h3>
                        <p
                            style="
                                font-size: 13px;
                                color: #000;
                                margin-bottom: 12px;
                                line-height: 1.5;
                            "
                        >
                            DARKER = HIGHER VALUE. ORANGE = ACTIVE GRADIENT.
                        </p>
                        <canvas id="weightsCanvas" style="width: 100%; height: 120px; border: 3px solid #000; background: #fff;"></canvas>
                    </div>

                    <div class="network-diagram">
                        <h3>Neural Network Architecture</h3>
                        <div class="network-viz" id="networkViz">
                            <div class="layer">
                                <div class="layer-label">
                                    Input Layer<br />(64 pixels)
                                </div>
                                <div class="layer-nodes">
                                    <div class="node"></div>
                                    <div class="node"></div>
                                    <div class="node"></div>
                                    <div class="node"></div>
                                    <div style="color: #555; font-size: 0.8em">
                                        ...
                                    </div>
                                    <div class="node"></div>
                                    <div class="node"></div>
                                </div>
                            </div>
                            <div class="arrow">→</div>
                            <div class="layer">
                                <div class="layer-label">
                                    Hidden Layer<br />(<span id="hiddenCount"
                                        >6</span
                                    >
                                    features)
                                </div>
                                <div class="layer-nodes" id="hiddenLayerViz">
                                    <div class="node hidden"></div>
                                    <div class="node hidden"></div>
                                    <div class="node hidden"></div>
                                    <div class="node hidden"></div>
                                    <div class="node hidden"></div>
                                    <div class="node hidden"></div>
                                </div>
                            </div>
                            <div class="arrow">→</div>
                            <div class="layer">
                                <div class="layer-label">
                                    Output Layer<br />(<span id="outputCount"
                                        >4</span
                                    >
                                    classes)
                                </div>
                                <div class="layer-nodes" id="outputLayerViz"></div>
                            </div>
                        </div>
                        <p
                            style="
                                font-size: 11px;
                                color: #000;
                                margin-top: 12px;
                                text-align: left;
                                border-top: 2px dotted #000;
                                padding-top: 8px;
                            "
                        >
                            WEIGHTS (ABOVE) = PARAMETERS CONNECTING INPUT TO
                            HIDDEN LAYER
                        </p>
                    </div>

                    <div class="draw-interface">
                        <h4>TRY THE NETWORK</h4>
                        <p
                            style="
                                font-size: 13px;
                                color: #000;
                                margin-bottom: 12px;
                                line-height: 1.5;
                            "
                        >
                            Draw an 8×8 pattern and watch the network classify it in real-time.
                        </p>
                        <div style="display: flex; gap: 20px; align-items: start;">
                            <div style="flex-shrink: 0;">
                                <div class="draw-canvas" id="drawCanvas"></div>
                                <div class="draw-controls">
                                    <button id="clearDrawing" class="secondary">
                                        Clear
                                    </button>
                                </div>
                            </div>
                            <div style="flex: 1; min-width: 0;">
                                <div class="prediction">
                                    PREDICTION: <span id="drawPrediction">—</span>
                                </div>
                                <div
                                    style="
                                        font-size: 13px;
                                        color: #000;
                                        margin-top: 8px;
                                    "
                                >
                                    CONFIDENCE: <span id="drawConfidence">—</span>
                                </div>
                                <div style="margin-top: 15px; padding-top: 15px; border-top: 2px dotted #000;">
                                    <div style="font-size: 12px; color: #000; margin-bottom: 8px; font-weight: bold;">
                                        HIDDEN LAYER (<span id="hiddenCountDraw">6</span> features)
                                    </div>
                                    <div id="activationsViz" style="display: flex; gap: 4px; flex-wrap: wrap; margin-bottom: 15px;"></div>

                                    <div style="font-size: 12px; color: #000; margin-bottom: 8px; font-weight: bold; padding-top: 10px; border-top: 1px dotted #ccc;">
                                        OUTPUT LAYER (<span id="outputCountDraw">4</span> classes)
                                    </div>
                                    <div id="outputActivationsViz" style="display: flex; gap: 4px; flex-wrap: wrap;"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="controls">
                    <div class="dataset-builder">
                        <h3>Pattern Library</h3>
                        <p>
                            Pick the synthetic pattern families to train on.
                            Adjust sample counts and noise to remix the
                            dataset.
                        </p>
                        <div
                            id="patternFamilyList"
                            class="pattern-family-list"
                        ></div>
                        <button
                            id="regenerateDatasetBtn"
                            class="secondary small"
                        >
                            REGENERATE DATASET
                        </button>
                    </div>
                    <div class="dataset-builder custom-pattern-builder">
                        <h3>Custom Pattern Builder</h3>
                        <p>
                            Sketch brand-new pattern families. Add a few
                            variations, choose how noisy the class should be,
                            and grow a fresh category from your prototypes.
                        </p>
                        <div class="custom-builder">
                            <div class="custom-builder-grid">
                                <div class="custom-builder-canvas">
                                    <div
                                        class="draw-canvas"
                                        id="customPatternCanvas"
                                    ></div>
                                    <div class="custom-builder-actions">
                                        <button
                                            id="customPatternClear"
                                            class="secondary tiny"
                                        >
                                            Clear Sketch
                                        </button>
                                        <button
                                            id="customPatternAdd"
                                            class="secondary tiny"
                                        >
                                            Add Variation
                                        </button>
                                    </div>
                                </div>
                                <div class="custom-builder-config">
                                    <div>
                                        <label for="customPatternName"
                                            >Pattern Name</label
                                        >
                                        <input
                                            type="text"
                                            id="customPatternName"
                                            placeholder="e.g. Spiral"
                                        />
                                    </div>
                                    <div class="custom-builder-slider">
                                        <label for="customPatternSamples"
                                            >Samples</label
                                        >
                                        <input
                                            type="range"
                                            id="customPatternSamples"
                                            min="24"
                                            max="240"
                                            step="12"
                                            value="60"
                                        />
                                        <span class="value"
                                            ><span id="customPatternSamplesValue"
                                                >60</span
                                            >
                                            samples</span
                                        >
                                    </div>
                                    <div class="custom-builder-slider">
                                        <label for="customPatternNoise"
                                            >Noise</label
                                        >
                                        <input
                                            type="range"
                                            id="customPatternNoise"
                                            min="0"
                                            max="0.45"
                                            step="0.01"
                                            value="0.18"
                                        />
                                        <span class="value"
                                            ><span id="customPatternNoiseValue"
                                                >18</span
                                            >
                                            % noise</span
                                        >
                                    </div>
                                    <div>
                                        <label>Variations</label>
                                        <div
                                            id="customPatternVariants"
                                            class="custom-variant-list"
                                        ></div>
                                    </div>
                                    <div
                                        class="builder-message"
                                        id="customPatternMessage"
                                    ></div>
                                    <button id="customPatternCreate">
                                        Create Pattern Type
                                    </button>
                                    <button
                                        id="customPatternReset"
                                        class="secondary small"
                                    >
                                        Reset Builder
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="algorithm-box">
                        <code>for each batch:
  gradient = ∂Loss/∂θ
  θ = θ - α · gradient

where:
  θ = network parameters (weights)
  α = learning rate (step size)</code>
                    </div>

                    <div class="control-group">
                        <label>Learning Rate (α)</label>
                        <input
                            type="range"
                            id="patternLearningRate"
                            min="0.01"
                            max="0.4"
                            step="0.01"
                            value="0.1"
                        />
                        <div class="value">
                            α = <span id="patternLearningRateValue">0.100</span>
                        </div>
                    </div>

                    <div class="control-group">
                        <label>Hidden Units</label>
                        <input
                            type="range"
                            id="hiddenUnits"
                            min="2"
                            max="12"
                            step="1"
                            value="6"
                        />
                        <div class="value">
                            <span id="hiddenUnitsValue">6</span>
                        </div>
                    </div>

                    <div class="control-group">
                        <label>Speed</label>
                        <input
                            type="range"
                            id="trainingSpeed"
                            min="0"
                            max="1"
                            step="0.001"
                            value="0.2"
                        />
                        <div class="value">
                            <span id="trainingSpeedValue">0.2</span>x
                        </div>
                    </div>

                    <button id="patternStartBtn">START LEARNING</button>
                    <button id="patternResetBtn" class="secondary">
                        RESET NETWORK
                    </button>

                    <div class="stats">
                        <div
                            style="
                                display: grid;
                                grid-template-columns: 1fr 150px;
                                gap: 15px;
                            "
                        >
                            <div>
                                <div>
                                    <span class="label">Iteration:</span>
                                    <span id="patternIteration">0</span>
                                </div>
                                <div>
                                    <span class="label">Loss:</span>
                                    <span id="patternLoss">0.000</span>
                                </div>
                                <div>
                                    <span class="label">Accuracy:</span>
                                    <span id="patternAccuracy">0%</span>
                                </div>
                                <div>
                                    <span class="label">Status:</span>
                                    <span id="patternStatus">Ready</span>
                                </div>
                            </div>
                            <div>
                                <canvas
                                    id="lossLandscape"
                                    style="
                                        width: 150px;
                                        height: 120px;
                                        border: 2px solid #000;
                                        background: #fff;
                                        cursor: pointer;
                                    "
                                ></canvas>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <script>
            // ============================================
            // PATTERN RECOGNITION
            // ============================================
            const patternCanvas = document.getElementById("patternCanvas");
            const patternCtx = patternCanvas.getContext("2d");
            const weightsCanvas = document.getElementById("weightsCanvas");
            const weightsCtx = weightsCanvas.getContext("2d");
            const classGalleryEl = document.getElementById("classGallery");
            const classCountText = document.getElementById("classCountText");
            const sampleCountText = document.getElementById("sampleCountText");
            const patternFamilyListEl = document.getElementById(
                "patternFamilyList",
            );
            const regenerateDatasetBtn = document.getElementById(
                "regenerateDatasetBtn",
            );
            const outputCountLabel = document.getElementById("outputCount");
            const outputCountDrawLabel = document.getElementById(
                "outputCountDraw",
            );

            const GRID_SIZE = 8;
            let trainingData = [];
            let W1 = []; // Input to hidden weights
            let b1 = []; // Hidden biases
            let W2 = []; // Hidden to output weights
            let b2 = []; // Output biases
            let hiddenUnits = 6;
            let patternLearningRate = 0.1;
            let patternIteration = 0;
            let patternRunning = false;
            let trainingSpeed = 0.2; // 0 to 1, controls steps per second multiplier
            let lastFrameTime = 0;
            let stepAccumulator = 0; // Fractional steps to carry over

            // Loss landscape tracking
            let trajectoryPoints = []; // Store [w1, w2, loss] for visualization
            const MAX_TRAJECTORY = 150; // Keep last N points

            // Current batch tracking for visualization
            let currentBatchIndices = [];

            // Track gradients for visualization
            let currentGradientsW1 = [];
            let currentGradientsW2 = [];
            let maxGradientNormW1 = 0;
            let maxGradientNormW2 = 0;
            const CALIBRATION_STEPS = 20; // Track max gradient for first N steps

            const patternLibrary = [
                {
                    id: "horizontal_stripes",
                    name: "Horizontal Stripes",
                    description:
                        "Alternating horizontal bands with jittered offsets.",
                    defaultEnabled: true,
                    defaultSamples: 75,
                    defaultNoise: 0.12,
                    previewSeed: 11,
                    generate({ rng, gridSize }) {
                        const pattern = new Array(gridSize * gridSize).fill(0);
                        const stripeHeight = 1 + Math.floor(rng() * 3);
                        const offset = Math.floor(rng() * stripeHeight);
                        for (let row = 0; row < gridSize; row++) {
                            const active =
                                Math.floor((row + offset) / stripeHeight) % 2 ===
                                0;
                            for (let col = 0; col < gridSize; col++) {
                                if (active) {
                                    pattern[row * gridSize + col] = 1;
                                }
                            }
                        }
                        return pattern;
                    },
                },
                {
                    id: "vertical_stripes",
                    name: "Vertical Stripes",
                    description: "Crisp vertical bars with random thickness.",
                    defaultEnabled: true,
                    defaultSamples: 75,
                    defaultNoise: 0.12,
                    previewSeed: 23,
                    generate({ rng, gridSize }) {
                        const pattern = new Array(gridSize * gridSize).fill(0);
                        const stripeWidth = 1 + Math.floor(rng() * 3);
                        const offset = Math.floor(rng() * stripeWidth);
                        for (let col = 0; col < gridSize; col++) {
                            const active =
                                Math.floor((col + offset) / stripeWidth) % 2 ===
                                0;
                            for (let row = 0; row < gridSize; row++) {
                                if (active) {
                                    pattern[row * gridSize + col] = 1;
                                }
                            }
                        }
                        return pattern;
                    },
                },
                {
                    id: "slash",
                    name: "Slash Diagonal",
                    description: "Strong / diagonals with soft falloff.",
                    defaultEnabled: true,
                    defaultSamples: 75,
                    defaultNoise: 0.14,
                    previewSeed: 37,
                    generate({ rng, gridSize }) {
                        const pattern = new Array(gridSize * gridSize).fill(0);
                        const thickness = 1 + Math.floor(rng() * 2);
                        const offset = Math.floor(rng() * (gridSize + 4)) - 2;
                        for (let row = 0; row < gridSize; row++) {
                            for (let col = 0; col < gridSize; col++) {
                                const diag = row + col;
                                if (Math.abs(diag - offset) <= thickness) {
                                    pattern[row * gridSize + col] = 1;
                                }
                            }
                        }
                        return pattern;
                    },
                },
                {
                    id: "checker",
                    name: "Checkerboard",
                    description: "Alternating squares with parity shifts.",
                    defaultEnabled: true,
                    defaultSamples: 75,
                    defaultNoise: 0.12,
                    previewSeed: 41,
                    generate({ rng, gridSize }) {
                        const pattern = new Array(gridSize * gridSize).fill(0);
                        const offsetRow = Math.floor(rng() * 2);
                        const offsetCol = Math.floor(rng() * 2);
                        for (let row = 0; row < gridSize; row++) {
                            for (let col = 0; col < gridSize; col++) {
                                if (
                                    (row + col + offsetRow + offsetCol) % 2 ===
                                    0
                                ) {
                                    pattern[row * gridSize + col] = 1;
                                }
                            }
                        }
                        return pattern;
                    },
                },
                {
                    id: "backslash",
                    name: "Backslash",
                    description: "\\ diagonals with variable offset.",
                    defaultEnabled: false,
                    defaultSamples: 60,
                    defaultNoise: 0.16,
                    previewSeed: 53,
                    generate({ rng, gridSize }) {
                        const pattern = new Array(gridSize * gridSize).fill(0);
                        const thickness = 1 + Math.floor(rng() * 2);
                        const offset = Math.floor(rng() * (gridSize + 4)) - 2;
                        for (let row = 0; row < gridSize; row++) {
                            for (let col = 0; col < gridSize; col++) {
                                const diag = col - row;
                                if (Math.abs(diag - offset) <= thickness) {
                                    pattern[row * gridSize + col] = 1;
                                }
                            }
                        }
                        return pattern;
                    },
                },
                {
                    id: "outline",
                    name: "Outline Box",
                    description: "Framed squares with random thickness.",
                    defaultEnabled: false,
                    defaultSamples: 60,
                    defaultNoise: 0.1,
                    previewSeed: 67,
                    generate({ rng, gridSize }) {
                        const pattern = new Array(gridSize * gridSize).fill(0);
                        const thickness = 1 + Math.floor(rng() * 2);
                        const inset = Math.floor(rng() * 2);
                        for (let row = inset; row < gridSize - inset; row++) {
                            for (
                                let col = inset;
                                col < gridSize - inset;
                                col++
                            ) {
                                const top = row < inset + thickness;
                                const bottom =
                                    row >= gridSize - inset - thickness;
                                const left = col < inset + thickness;
                                const right = col >= gridSize - inset - thickness;
                                if (top || bottom || left || right) {
                                    pattern[row * gridSize + col] = 1;
                                }
                            }
                        }
                        return pattern;
                    },
                },
                {
                    id: "plus",
                    name: "Plus",
                    description: "Cross shapes centred with wobble.",
                    defaultEnabled: false,
                    defaultSamples: 60,
                    defaultNoise: 0.18,
                    previewSeed: 79,
                    generate({ rng, gridSize }) {
                        const pattern = new Array(gridSize * gridSize).fill(0);
                        const center = Math.floor(gridSize / 2) +
                            (rng() < 0.5 ? 0 : -1);
                        const armWidth = 1 + Math.floor(rng() * 2);
                        for (let row = 0; row < gridSize; row++) {
                            for (let col = 0; col < gridSize; col++) {
                                const vertical =
                                    Math.abs(col - center) < armWidth;
                                const horizontal =
                                    Math.abs(row - center) < armWidth;
                                if (vertical || horizontal) {
                                    pattern[row * gridSize + col] = 1;
                                }
                            }
                        }
                        return pattern;
                    },
                },
                {
                    id: "diamond",
                    name: "Diamond",
                    description: "Rhombus silhouettes with soft corners.",
                    defaultEnabled: false,
                    defaultSamples: 60,
                    defaultNoise: 0.15,
                    previewSeed: 83,
                    generate({ rng, gridSize }) {
                        const pattern = new Array(gridSize * gridSize).fill(0);
                        const center = (gridSize - 1) / 2;
                        const radius = 2.5 + rng() * 1.5;
                        for (let row = 0; row < gridSize; row++) {
                            for (let col = 0; col < gridSize; col++) {
                                const dist =
                                    Math.abs(row - center) +
                                    Math.abs(col - center);
                                if (dist <= radius) {
                                    pattern[row * gridSize + col] = 1;
                                }
                            }
                        }
                        return pattern;
                    },
                },
                {
                    id: "clusters",
                    name: "Dot Clusters",
                    description: "Small constellations of bright pixels.",
                    defaultEnabled: false,
                    defaultSamples: 60,
                    defaultNoise: 0.22,
                    previewSeed: 97,
                    generate({ rng, gridSize }) {
                        const pattern = new Array(gridSize * gridSize).fill(0);
                        const clusters = 2 + Math.floor(rng() * 3);
                        for (let c = 0; c < clusters; c++) {
                            const cx = Math.floor(rng() * gridSize);
                            const cy = Math.floor(rng() * gridSize);
                            const size = 1 + Math.floor(rng() * 2);
                            for (let dy = -size; dy <= size; dy++) {
                                for (let dx = -size; dx <= size; dx++) {
                                    if (
                                        Math.abs(dx) + Math.abs(dy) <= size &&
                                        rng() > 0.1
                                    ) {
                                        const nx = cx + dx;
                                        const ny = cy + dy;
                                        if (
                                            nx >= 0 &&
                                            nx < gridSize &&
                                            ny >= 0 &&
                                            ny < gridSize
                                        ) {
                                            pattern[ny * gridSize + nx] = 1;
                                        }
                                    }
                                }
                            }
                        }
                        return pattern;
                    },
                },
            ];

            const patternLibraryById = new Map();
            for (const family of patternLibrary) {
                patternLibraryById.set(family.id, family);
            }

            const datasetConfig = new Map(
                patternLibrary.map((family) => [
                    family.id,
                    {
                        enabled: family.defaultEnabled,
                        samples: family.defaultSamples,
                        noise: family.defaultNoise,
                    },
                ]),
            );

            let activeFamilies = [];
            let classNames = [];
            let totalSamples = 0;
            const patternFamilyElements = new Map();
            let datasetUpdateTimeout = null;
            let customSketchpad = null;
            let drawSketchpad = null;

            function registerCustomPatternFamily({
                name,
                prototypes,
                samples,
                noise,
            }) {
                if (!prototypes || prototypes.length === 0) {
                    return null;
                }

                const id = `custom_${Date.now()}_${Math.floor(
                    Math.random() * 100000,
                )}`;
                const family = {
                    id,
                    name,
                    description: `Custom pattern with ${prototypes.length} variations.`,
                    defaultEnabled: true,
                    defaultSamples: samples,
                    defaultNoise: noise,
                    previewSeed: Math.floor(Math.random() * 1e9),
                    isCustom: true,
                    prototypes: prototypes.map((pattern) => pattern.slice()),
                    generate({ rng }) {
                        if (!this.prototypes.length) {
                            return new Array(GRID_SIZE * GRID_SIZE).fill(0);
                        }
                        const choice = Math.floor(rng() * this.prototypes.length);
                        return this.prototypes[choice].slice();
                    },
                };

                patternLibrary.push(family);
                patternLibraryById.set(id, family);
                datasetConfig.set(id, {
                    enabled: true,
                    samples,
                    noise,
                });

                return family;
            }

            function removePatternFamily(familyId) {
                const family = patternLibraryById.get(familyId);
                if (!family || !family.isCustom) {
                    return;
                }

                const index = patternLibrary.findIndex(
                    (entry) => entry.id === familyId,
                );
                if (index >= 0) {
                    patternLibrary.splice(index, 1);
                }

                patternLibraryById.delete(familyId);
                datasetConfig.delete(familyId);
                patternFamilyElements.delete(familyId);
            }

            function createRng(seed) {
                let value = seed >>> 0;
                return function () {
                    value += 0x6d2b79f5;
                    let t = value;
                    t = Math.imul(t ^ (t >>> 15), t | 1);
                    t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
                    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
                };
            }

            function clonePattern(pattern) {
                return pattern.slice();
            }

            function flipHorizontal(pattern) {
                const result = new Array(pattern.length).fill(0);
                for (let row = 0; row < GRID_SIZE; row++) {
                    for (let col = 0; col < GRID_SIZE; col++) {
                        const idx = row * GRID_SIZE + col;
                        const mirrored = row * GRID_SIZE + (GRID_SIZE - 1 - col);
                        result[idx] = pattern[mirrored];
                    }
                }
                return result;
            }

            function flipVertical(pattern) {
                const result = new Array(pattern.length).fill(0);
                for (let row = 0; row < GRID_SIZE; row++) {
                    for (let col = 0; col < GRID_SIZE; col++) {
                        const idx = row * GRID_SIZE + col;
                        const mirrored =
                            (GRID_SIZE - 1 - row) * GRID_SIZE + col;
                        result[idx] = pattern[mirrored];
                    }
                }
                return result;
            }

            function transposePattern(pattern) {
                const result = new Array(pattern.length).fill(0);
                for (let row = 0; row < GRID_SIZE; row++) {
                    for (let col = 0; col < GRID_SIZE; col++) {
                        result[col * GRID_SIZE + row] =
                            pattern[row * GRID_SIZE + col];
                    }
                }
                return result;
            }

            function shiftPattern(pattern, dx, dy) {
                if (dx === 0 && dy === 0) return clonePattern(pattern);
                const result = new Array(pattern.length).fill(0);
                for (let row = 0; row < GRID_SIZE; row++) {
                    for (let col = 0; col < GRID_SIZE; col++) {
                        const newRow = row + dy;
                        const newCol = col + dx;
                        if (
                            newRow >= 0 &&
                            newRow < GRID_SIZE &&
                            newCol >= 0 &&
                            newCol < GRID_SIZE
                        ) {
                            result[newRow * GRID_SIZE + newCol] =
                                pattern[row * GRID_SIZE + col];
                        }
                    }
                }
                return result;
            }

            function applyRandomTransforms(pattern, rng) {
                let result = clonePattern(pattern);
                if (rng() < 0.5) {
                    result = flipHorizontal(result);
                }
                if (rng() < 0.5) {
                    result = flipVertical(result);
                }
                if (rng() < 0.25) {
                    result = transposePattern(result);
                }
                const shiftX = Math.floor(rng() * 3) - 1;
                const shiftY = Math.floor(rng() * 3) - 1;
                if (shiftX !== 0 || shiftY !== 0) {
                    result = shiftPattern(result, shiftX, shiftY);
                }
                return result;
            }

            function applyNoise(pattern, noiseLevel, rng) {
                const result = clonePattern(pattern);
                if (noiseLevel <= 0) return result;
                for (let i = 0; i < result.length; i++) {
                    if (rng() < noiseLevel) {
                        result[i] = result[i] === 1 ? 0 : 1;
                    }
                }

                // Occasional dilation/erosion to create structured noise
                if (noiseLevel > 0.18 && rng() < 0.4) {
                    const dilated = clonePattern(result);
                    for (let row = 0; row < GRID_SIZE; row++) {
                        for (let col = 0; col < GRID_SIZE; col++) {
                            const idx = row * GRID_SIZE + col;
                            if (result[idx] === 1) {
                                continue;
                            }
                            let neighbors = 0;
                            for (let dy = -1; dy <= 1; dy++) {
                                for (let dx = -1; dx <= 1; dx++) {
                                    const nr = row + dy;
                                    const nc = col + dx;
                                    if (
                                        nr >= 0 &&
                                        nr < GRID_SIZE &&
                                        nc >= 0 &&
                                        nc < GRID_SIZE &&
                                        !(dx === 0 && dy === 0)
                                    ) {
                                        neighbors += result[nr * GRID_SIZE + nc];
                                    }
                                }
                            }
                            if (neighbors >= 5) {
                                dilated[idx] = 1;
                            }
                        }
                    }
                    return dilated;
                }

                return result;
            }

            function renderPatternPreview(element, basePattern, noisyPattern) {
                element.innerHTML = "";
                for (let i = 0; i < basePattern.length; i++) {
                    const cell = document.createElement("div");
                    if (noisyPattern[i] === 1) {
                        cell.classList.add("filled");
                    }
                    if (noisyPattern[i] !== basePattern[i]) {
                        cell.classList.add("changed");
                    }
                    element.appendChild(cell);
                }
            }

            function updatePatternFamilyStats(familyId) {
                const config = datasetConfig.get(familyId);
                const elements = patternFamilyElements.get(familyId);
                const family = patternLibraryById.get(familyId);
                if (!config || !elements) return;
                const noisePercent = Math.round(config.noise * 100);
                let statsText = `${config.samples} samples · ${noisePercent}% noise`;
                if (family && Array.isArray(family.prototypes)) {
                    statsText += ` · ${family.prototypes.length} variations`;
                }
                if (elements.statsLabel) {
                    elements.statsLabel.textContent = statsText;
                }
                if (elements.noiseValue) {
                    elements.noiseValue.textContent = `${noisePercent}%`;
                }
                if (elements.sampleValue) {
                    elements.sampleValue.textContent = config.samples;
                }
            }

            function updatePatternFamilyPreview(familyId) {
                const family = patternLibraryById.get(familyId);
                const elements = patternFamilyElements.get(familyId);
                if (!family || !elements) return;
                const config = datasetConfig.get(familyId);
                const rng = createRng(family.previewSeed);
                if (
                    family.prototypes &&
                    Array.isArray(family.prototypes) &&
                    family.prototypes.length === 0
                ) {
                    elements.preview.innerHTML =
                        "<div style=\"font-size:10px;color:#555;padding:6px;text-align:center;\">Add variations</div>";
                    return;
                }
                const base = applyRandomTransforms(
                    family.generate({ rng, gridSize: GRID_SIZE }),
                    rng,
                );
                const noisy = applyNoise(base, config.noise, rng);
                renderPatternPreview(elements.preview, base, noisy);
            }

            function updateAllPatternPreviews() {
                for (const family of patternLibrary) {
                    updatePatternFamilyPreview(family.id);
                    updatePatternFamilyStats(family.id);
                }
            }

            function updateDatasetSummaries() {
                classCountText.textContent = activeFamilies.length;
                sampleCountText.textContent = totalSamples;
                outputCountLabel.textContent = activeFamilies.length;
                outputCountDrawLabel.textContent = activeFamilies.length;
            }

            function renderClassGallery() {
                classGalleryEl.innerHTML = "";
                if (activeFamilies.length === 0) {
                    const card = document.createElement("div");
                    card.className = "class-card";
                    const title = document.createElement("h4");
                    title.textContent = "NO DATA";
                    card.appendChild(title);
                    const message = document.createElement("div");
                    message.style.fontSize = "11px";
                    message.style.color = "#555";
                    message.textContent =
                        "Enable pattern families to generate a dataset.";
                    card.appendChild(message);
                    classGalleryEl.appendChild(card);
                    return;
                }

                for (const entry of activeFamilies) {
                    const { family, config } = entry;
                    const card = document.createElement("div");
                    card.className = "class-card";
                    const title = document.createElement("h4");
                    title.textContent = family.name.toUpperCase();
                    card.appendChild(title);
                    const preview = document.createElement("div");
                    preview.className = "class-preview-grid";
                    card.appendChild(preview);
                    const meta = document.createElement("div");
                    meta.style.fontSize = "10px";
                    meta.style.color = "#000";
                    let metaText = `${config.samples} samples · ${Math.round(
                        config.noise * 100,
                    )}% noise`;
                    if (family.prototypes) {
                        metaText += ` · ${family.prototypes.length} variations`;
                    }
                    meta.textContent = metaText;
                    card.appendChild(meta);
                    const rng = createRng(family.previewSeed + 1337);
                    const base = applyRandomTransforms(
                        family.generate({ rng, gridSize: GRID_SIZE }),
                        rng,
                    );
                    const noisy = applyNoise(base, config.noise, rng);
                    renderPatternPreview(preview, base, noisy);
                    classGalleryEl.appendChild(card);
                }
            }

            function scheduleDatasetUpdate(immediate = false) {
                if (immediate) {
                    if (datasetUpdateTimeout) {
                        clearTimeout(datasetUpdateTimeout);
                        datasetUpdateTimeout = null;
                    }
                    regenerateDataset();
                    return;
                }
                if (datasetUpdateTimeout) {
                    clearTimeout(datasetUpdateTimeout);
                }
                datasetUpdateTimeout = setTimeout(() => {
                    datasetUpdateTimeout = null;
                    regenerateDataset();
                }, 180);
            }

            function buildPatternLibraryUI() {
                patternFamilyListEl.innerHTML = "";
                patternFamilyElements.clear();

                for (const family of patternLibrary) {
                    const config = datasetConfig.get(family.id);
                    const container = document.createElement("div");
                    container.className = "pattern-family";
                    if (!config.enabled) {
                        container.classList.add("disabled");
                    }

                    const header = document.createElement("div");
                    header.className = "pattern-family-header";

                    const label = document.createElement("label");
                    const checkbox = document.createElement("input");
                    checkbox.type = "checkbox";
                    checkbox.checked = config.enabled;
                    label.appendChild(checkbox);
                    const nameSpan = document.createElement("span");
                    nameSpan.textContent = family.name.toUpperCase();
                    label.appendChild(nameSpan);
                    header.appendChild(label);

                    const stats = document.createElement("div");
                    stats.style.fontSize = "10px";
                    stats.style.color = "#000";
                    header.appendChild(stats);

                    if (family.isCustom) {
                        const removeBtn = document.createElement("button");
                        removeBtn.type = "button";
                        removeBtn.className = "secondary tiny remove-family";
                        removeBtn.textContent = "Remove";
                        removeBtn.addEventListener("click", (event) => {
                            event.preventDefault();
                            event.stopPropagation();
                            removePatternFamily(family.id);
                            buildPatternLibraryUI();
                            regenerateDataset();
                        });
                        header.appendChild(removeBtn);
                    }

                    container.appendChild(header);

                    if (family.description) {
                        const description = document.createElement("div");
                        description.style.fontSize = "11px";
                        description.style.color = "#444";
                        description.textContent = family.description;
                        container.appendChild(description);
                    }

                    const body = document.createElement("div");
                    body.className = "pattern-family-body";

                    const preview = document.createElement("div");
                    preview.className = "pattern-preview-grid small";
                    body.appendChild(preview);

                    const controls = document.createElement("div");
                    controls.className = "pattern-controls";

                    const sampleWrapper = document.createElement("div");
                    const sampleLabel = document.createElement("label");
                    sampleLabel.textContent = "Samples";
                    const sampleInput = document.createElement("input");
                    sampleInput.type = "range";
                    sampleInput.min = "24";
                    sampleInput.max = "240";
                    sampleInput.step = "12";
                    sampleInput.value = config.samples;
                    const sampleValue = document.createElement("span");
                    sampleValue.className = "value";
                    sampleWrapper.appendChild(sampleLabel);
                    sampleWrapper.appendChild(sampleInput);
                    sampleWrapper.appendChild(sampleValue);
                    controls.appendChild(sampleWrapper);

                    const noiseWrapper = document.createElement("div");
                    const noiseLabel = document.createElement("label");
                    noiseLabel.textContent = "Noise";
                    const noiseInput = document.createElement("input");
                    noiseInput.type = "range";
                    noiseInput.min = "0";
                    noiseInput.max = "0.45";
                    noiseInput.step = "0.01";
                    noiseInput.value = config.noise;
                    const noiseValue = document.createElement("span");
                    noiseValue.className = "value";
                    noiseWrapper.appendChild(noiseLabel);
                    noiseWrapper.appendChild(noiseInput);
                    noiseWrapper.appendChild(noiseValue);
                    controls.appendChild(noiseWrapper);

                    body.appendChild(controls);
                    container.appendChild(body);

                    patternFamilyListEl.appendChild(container);

                    patternFamilyElements.set(family.id, {
                        container,
                        checkbox,
                        sampleInput,
                        sampleValue,
                        noiseInput,
                        noiseValue,
                        preview,
                        statsLabel: stats,
                    });

                    checkbox.addEventListener("change", () => {
                        datasetConfig.get(family.id).enabled = checkbox.checked;
                        container.classList.toggle("disabled", !checkbox.checked);
                        updatePatternFamilyStats(family.id);
                        scheduleDatasetUpdate(true);
                    });

                    sampleInput.addEventListener("input", () => {
                        datasetConfig.get(family.id).samples = parseInt(
                            sampleInput.value,
                            10,
                        );
                        updatePatternFamilyStats(family.id);
                        scheduleDatasetUpdate();
                    });

                    noiseInput.addEventListener("input", () => {
                        datasetConfig.get(family.id).noise = parseFloat(
                            noiseInput.value,
                        );
                        updatePatternFamilyStats(family.id);
                        updatePatternFamilyPreview(family.id);
                        scheduleDatasetUpdate();
                    });
                }

                updateAllPatternPreviews();
            }

            function updateNetworkDiagram() {
                // Update hidden layer count
                document.getElementById("hiddenCount").textContent =
                    hiddenUnits;
                document.getElementById("hiddenCountDraw").textContent =
                    hiddenUnits;

                // Update hidden layer visualization
                const hiddenLayerViz =
                    document.getElementById("hiddenLayerViz");
                hiddenLayerViz.innerHTML = "";

                for (let i = 0; i < hiddenUnits; i++) {
                    const node = document.createElement("div");
                    node.className = "node hidden";
                    hiddenLayerViz.appendChild(node);
                }

                // Update output layer visualization
                outputCountLabel.textContent = activeFamilies.length;
                outputCountDrawLabel.textContent = activeFamilies.length;
                const outputLayerViz = document.getElementById(
                    "outputLayerViz",
                );
                outputLayerViz.innerHTML = "";

                if (activeFamilies.length === 0) {
                    const placeholder = document.createElement("div");
                    placeholder.style.fontSize = "10px";
                    placeholder.style.color = "#555";
                    placeholder.textContent = "—";
                    outputLayerViz.appendChild(placeholder);
                } else {
                    for (let i = 0; i < activeFamilies.length; i++) {
                        const node = document.createElement("div");
                        node.className = "node output";
                        outputLayerViz.appendChild(node);
                    }
                }
            }

            function resizePatternCanvas() {
                const rect = patternCanvas.getBoundingClientRect();
                const dpr = window.devicePixelRatio || 1;

                // Calculate required height based on samples
                const topPadding = 30;
                const cols = 25;
                const estimatedSamples =
                    trainingData.length || Math.max(totalSamples, cols);
                const rows = Math.max(1, Math.ceil(estimatedSamples / cols));
                const cellSize = rect.width / cols;
                const requiredHeight = topPadding + (rows * cellSize);

                patternCanvas.width = rect.width * dpr;
                patternCanvas.height = requiredHeight * dpr;

                patternCtx.scale(dpr, dpr);

                if (trainingData.length > 0) {
                    updatePatternStats();
                    drawPattern();
                    visualizeWeights();
                }
            }
            resizePatternCanvas();
            resizeWeightsCanvas();
            window.addEventListener("resize", () => {
                resizePatternCanvas();
                resizeWeightsCanvas();
                resizeLossCanvas();
                drawLossLandscape();
                visualizeWeights();
            });

            function relu(x) {
                return Math.max(0, x);
            }

            function reluDerivative(x) {
                return x > 0 ? 1 : 0;
            }

            function sigmoid(x) {
                return 1 / (1 + Math.exp(-x));
            }

            function sigmoidDerivative(x) {
                const s = sigmoid(x);
                return s * (1 - s);
            }

            function generatePatterns() {
                trainingData = [];
                activeFamilies = [];
                classNames = [];
                totalSamples = 0;

                const active = [];
                for (const family of patternLibrary) {
                    const config = datasetConfig.get(family.id);
                    if (config && config.enabled && config.samples > 0) {
                        active.push({ family, config });
                    }
                }

                activeFamilies = active.map(({ family, config }) => ({
                    family,
                    config,
                }));
                classNames = activeFamilies.map(({ family }) => family.name);
                totalSamples = activeFamilies.reduce(
                    (sum, { config }) => sum + config.samples,
                    0,
                );

                if (activeFamilies.length === 0) {
                    renderClassGallery();
                    updateDatasetSummaries();
                    return;
                }

                const baseSeed = Math.floor(Math.random() * 1e9);

                activeFamilies.forEach(({ family, config }, classIndex) => {
                    for (let i = 0; i < config.samples; i++) {
                        const rng = createRng(
                            baseSeed + classIndex * 9973 + i * 53,
                        );
                        const basePattern = applyRandomTransforms(
                            family.generate({ rng, gridSize: GRID_SIZE }),
                            rng,
                        );
                        const noisyPattern = applyNoise(
                            basePattern,
                            config.noise,
                            rng,
                        );
                        trainingData.push({
                            input: noisyPattern,
                            label: classIndex,
                            familyId: family.id,
                        });
                    }
                });

                for (let i = trainingData.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [trainingData[i], trainingData[j]] = [
                        trainingData[j],
                        trainingData[i],
                    ];
                }

                renderClassGallery();
                updateDatasetSummaries();
            }

            function regenerateDataset({ resetNetwork = true } = {}) {
                patternRunning = false;
                document.getElementById("patternStartBtn").textContent =
                    "START LEARNING";
                lastFrameTime = 0;
                stepAccumulator = 0;

                generatePatterns();

                if (resetNetwork) {
                    initPatternNetwork();
                }

                updateNetworkDiagram();
                resizePatternCanvas();
                drawPattern();
                visualizeWeights();
                drawLossLandscape();
                updatePatternStats();
                classifyDrawing();
            }

            function initPatternNetwork() {
                const inputSize = GRID_SIZE * GRID_SIZE;
                const outputSize = activeFamilies.length;

                // He initialization for ReLU: std = sqrt(2 / fan_in)
                const std_W1 = Math.sqrt(2 / inputSize);
                const std_W2 = Math.sqrt(2 / Math.max(hiddenUnits, 1));

                W1 = [];
                for (let i = 0; i < hiddenUnits; i++) {
                    W1[i] = [];
                    for (let j = 0; j < inputSize; j++) {
                        // Box-Muller transform for Gaussian sampling
                        const u1 = Math.random();
                        const u2 = Math.random();
                        const z =
                            Math.sqrt(-2 * Math.log(u1)) *
                            Math.cos(2 * Math.PI * u2);
                        W1[i][j] = z * std_W1;
                    }
                }

                b1 = new Array(hiddenUnits).fill(0);

                W2 = [];
                for (let i = 0; i < outputSize; i++) {
                    W2[i] = [];
                    for (let j = 0; j < hiddenUnits; j++) {
                        const u1 = Math.random();
                        const u2 = Math.random();
                        const z =
                            Math.sqrt(-2 * Math.log(u1)) *
                            Math.cos(2 * Math.PI * u2);
                        W2[i][j] = z * std_W2;
                    }
                }

                b2 = new Array(outputSize).fill(0);

                patternIteration = 0;
                trajectoryPoints = []; // Reset trajectory
                currentGradientsW1 = []; // Reset gradients
                currentGradientsW2 = [];
                maxGradientNormW1 = 0; // Reset max gradient
                maxGradientNormW2 = 0;

                // Initialize with random batch for visualization
                currentBatchIndices = [];
                const desiredBatch = Math.min(4, trainingData.length);
                const usedIndices = new Set();
                while (currentBatchIndices.length < desiredBatch) {
                    const idx = Math.floor(Math.random() * trainingData.length);
                    if (!usedIndices.has(idx)) {
                        usedIndices.add(idx);
                        currentBatchIndices.push(idx);
                    }
                }

                classifyDrawing();
            }

            // Track 2D projection of weights for visualization
            function getWeightProjection() {
                // Use first two weights from W1 as our 2D projection
                return [W1[0][0], W1[0][1]];
            }

            function forwardPass(input) {
                // Hidden layer
                const hidden = new Array(hiddenUnits);
                const hiddenRaw = new Array(hiddenUnits);
                for (let i = 0; i < hiddenUnits; i++) {
                    let sum = b1[i];
                    for (let j = 0; j < input.length; j++) {
                        sum += W1[i][j] * input[j];
                    }
                    hiddenRaw[i] = sum;
                    hidden[i] = relu(sum);
                }

                // Output layer
                const outputSize = W2.length;
                const output = new Array(outputSize).fill(0);
                const outputRaw = new Array(outputSize).fill(0);

                if (outputSize > 0) {
                    for (let i = 0; i < outputSize; i++) {
                        let sum = b2[i];
                        for (let j = 0; j < hiddenUnits; j++) {
                            sum += W2[i][j] * hidden[j];
                        }
                        outputRaw[i] = sum;
                    }

                    const maxVal = Math.max(...outputRaw);
                    const expVals = outputRaw.map((x) => Math.exp(x - maxVal));
                    const sumExp = expVals.reduce((a, b) => a + b, 0) || 1;
                    for (let i = 0; i < outputSize; i++) {
                        output[i] = expVals[i] / sumExp;
                    }
                }

                return { hidden, hiddenRaw, output, outputRaw };
            }

            function patternSGDStep() {
                if (trainingData.length === 0 || W2.length === 0) {
                    return;
                }

                // Sample random batch
                const batchIndices = [];
                const batch = [];
                const usedIndices = new Set();

                // Sample 4 random examples for the batch
                const desiredBatch = Math.min(4, trainingData.length);
                while (batch.length < desiredBatch) {
                    const idx = Math.floor(Math.random() * trainingData.length);
                    if (!usedIndices.has(idx)) {
                        usedIndices.add(idx);
                        batchIndices.push(idx);
                        batch.push(trainingData[idx]);
                    }
                }

                // Store for visualization
                currentBatchIndices = batchIndices;

                // Process each sample in batch
                const allGradients = { W1: [], b1: [], W2: [], b2: [] };
                const outputSize = W2.length;

                for (const sample of batch) {
                    const input = sample.input;
                    const label = sample.label;

                    // Forward pass
                    const { hidden, hiddenRaw, output, outputRaw } =
                        forwardPass(input);

                    // Compute output gradient (cross-entropy + softmax)
                    const outputGrad = output.map((value, idx) =>
                        idx === label ? value - 1 : value,
                    );

                    // Backprop to hidden layer
                    const hiddenGrad = new Array(hiddenUnits).fill(0);
                    for (let i = 0; i < hiddenUnits; i++) {
                        for (let j = 0; j < outputSize; j++) {
                            hiddenGrad[i] += outputGrad[j] * W2[j][i];
                        }
                        hiddenGrad[i] *= reluDerivative(hiddenRaw[i]);
                    }

                    // Accumulate gradients
                    if (!allGradients.W1.length) {
                        allGradients.W1 = W1.map((row) => row.map(() => 0));
                        allGradients.b1 = new Array(hiddenUnits).fill(0);
                        allGradients.W2 = W2.map((row) => row.map(() => 0));
                        allGradients.b2 = new Array(outputSize).fill(0);
                    }

                    for (let i = 0; i < outputSize; i++) {
                        for (let j = 0; j < hiddenUnits; j++) {
                            allGradients.W2[i][j] += outputGrad[i] * hidden[j];
                        }
                        allGradients.b2[i] += outputGrad[i];
                    }

                    for (let i = 0; i < hiddenUnits; i++) {
                        for (let j = 0; j < input.length; j++) {
                            allGradients.W1[i][j] += hiddenGrad[i] * input[j];
                        }
                        allGradients.b1[i] += hiddenGrad[i];
                    }
                }

                // Average gradients and store for visualization
                const batchSize = batch.length;

                // Store W1 gradients
                currentGradientsW1 = [];
                let stepMaxGradW1 = 0;
                for (let i = 0; i < hiddenUnits; i++) {
                    currentGradientsW1[i] = [];
                    for (let j = 0; j < GRID_SIZE * GRID_SIZE; j++) {
                        const grad = Math.abs(
                            allGradients.W1[i][j] / batchSize,
                        );
                        currentGradientsW1[i][j] = grad;
                        stepMaxGradW1 = Math.max(stepMaxGradW1, grad);
                    }
                }

                // Store W2 gradients
                currentGradientsW2 = [];
                let stepMaxGradW2 = 0;
                for (let i = 0; i < outputSize; i++) {
                    currentGradientsW2[i] = [];
                    for (let j = 0; j < hiddenUnits; j++) {
                        const grad = Math.abs(
                            allGradients.W2[i][j] / batchSize,
                        );
                        currentGradientsW2[i][j] = grad;
                        stepMaxGradW2 = Math.max(stepMaxGradW2, grad);
                    }
                }

                // Track maximum gradient during calibration period
                if (patternIteration < CALIBRATION_STEPS) {
                    maxGradientNormW1 = Math.max(maxGradientNormW1, stepMaxGradW1);
                    maxGradientNormW2 = Math.max(maxGradientNormW2, stepMaxGradW2);
                }

                // Apply gradients
                for (let i = 0; i < outputSize; i++) {
                    for (let j = 0; j < hiddenUnits; j++) {
                        W2[i][j] -=
                            (patternLearningRate * allGradients.W2[i][j]) /
                            batchSize;
                    }
                    b2[i] -=
                        (patternLearningRate * allGradients.b2[i]) / batchSize;
                }

                for (let i = 0; i < hiddenUnits; i++) {
                    for (let j = 0; j < GRID_SIZE * GRID_SIZE; j++) {
                        W1[i][j] -=
                            (patternLearningRate * allGradients.W1[i][j]) /
                            batchSize;
                    }
                    b1[i] -=
                        (patternLearningRate * allGradients.b1[i]) / batchSize;
                }

                patternIteration++;

                // Track trajectory for loss landscape (every 5 iterations)
                if (patternIteration % 5 === 0) {
                    const [w1, w2] = getWeightProjection();
                    const loss = computePatternStats().loss;
                    trajectoryPoints.push({ w1, w2, loss });
                    if (trajectoryPoints.length > MAX_TRAJECTORY) {
                        trajectoryPoints.shift();
                    }
                }
            }

            function computePatternStats() {
                if (trainingData.length === 0 || W2.length === 0) {
                    return { loss: 0, accuracy: 0 };
                }

                let totalLoss = 0;
                let correct = 0;

                for (const sample of trainingData) {
                    const { output } = forwardPass(sample.input);
                    if (output.length === 0) continue;

                    let predicted = 0;
                    let maxVal = -Infinity;
                    for (let i = 0; i < output.length; i++) {
                        if (output[i] > maxVal) {
                            maxVal = output[i];
                            predicted = i;
                        }
                    }
                    if (predicted === sample.label) correct++;

                    const prob = output[sample.label] || 1e-10;
                    totalLoss += -Math.log(prob + 1e-10);
                }

                return {
                    loss: totalLoss / trainingData.length,
                    accuracy: (correct / trainingData.length) * 100,
                };
            }

            function drawPattern() {
                const rect = patternCanvas.getBoundingClientRect();
                const width = rect.width;
                const height = rect.height;

                patternCtx.fillStyle = "#fff";
                patternCtx.fillRect(0, 0, width, height);

                // Draw legend at top
                patternCtx.font = "11px 'Berkeley Mono', monospace";
                patternCtx.fillStyle = "#000";
                patternCtx.fillText("■ CORRECT", 10, 15);
                patternCtx.fillStyle = "#ff0000";
                patternCtx.fillText("■ WRONG", 90, 15);

                // Draw batch indicator - white square with black border
                patternCtx.fillStyle = "#fff";
                patternCtx.fillRect(170, 6, 10, 10);
                patternCtx.strokeStyle = "#000";
                patternCtx.lineWidth = 2;
                patternCtx.strokeRect(170, 6, 10, 10);

                patternCtx.fillStyle = "#000";
                patternCtx.font = "11px 'Berkeley Mono', monospace";
                patternCtx.fillText("BATCH", 185, 15);

                if (trainingData.length === 0) {
                    patternCtx.font = "13px 'Berkeley Mono', monospace";
                    patternCtx.fillStyle = "#555";
                    patternCtx.fillText(
                        "No samples yet. Enable pattern families to see data.",
                        10,
                        55,
                    );
                    return;
                }

                const topPadding = 30;
                const cols = 25;
                const rows = Math.max(1, Math.ceil(trainingData.length / cols));
                const cellSize = width / cols;
                const pixelSize = cellSize / GRID_SIZE;

                for (let i = 0; i < trainingData.length; i++) {
                    const sample = trainingData[i];
                    const col = i % cols;
                    const row = Math.floor(i / cols);
                    const x = col * cellSize + 2;
                    const y = row * cellSize + topPadding + 2;

                    const isInBatch = currentBatchIndices.includes(i);

                    // Predict and check correctness
                    const { output } = forwardPass(sample.input);
                    let predicted = -1;
                    let maxVal = -Infinity;
                    for (let idx = 0; idx < output.length; idx++) {
                        if (output[idx] > maxVal) {
                            maxVal = output[idx];
                            predicted = idx;
                        }
                    }
                    const isCorrect =
                        predicted === sample.label && predicted !== -1;

                    // Draw pattern (very small)
                    for (let py = 0; py < GRID_SIZE; py++) {
                        for (let px = 0; px < GRID_SIZE; px++) {
                            const idx = py * GRID_SIZE + px;
                            if (sample.input[idx] === 1) {
                                // Color based on correctness and batch membership
                                if (isInBatch) {
                                    patternCtx.fillStyle = "#000";
                                } else {
                                    patternCtx.fillStyle = isCorrect
                                        ? "#000"
                                        : "#ff0000";
                                }
                                patternCtx.fillRect(
                                    x + px * pixelSize,
                                    y + py * pixelSize,
                                    pixelSize - 0.3,
                                    pixelSize - 0.3,
                                );
                            }
                        }
                    }

                    // Draw border based on correctness
                    if (isInBatch) {
                        patternCtx.strokeStyle = "#000";
                        patternCtx.lineWidth = 2;
                    } else {
                        patternCtx.strokeStyle = isCorrect
                            ? "#00000033"
                            : "#ff000033";
                        patternCtx.lineWidth = 1;
                    }
                    patternCtx.strokeRect(
                        x - 0.5,
                        y - 0.5,
                        cellSize - 3,
                        cellSize - 3,
                    );
                }
            }

            function resizeWeightsCanvas() {
                const rect = weightsCanvas.getBoundingClientRect();
                const dpr = window.devicePixelRatio || 1;
                weightsCanvas.width = rect.width * dpr;
                weightsCanvas.height = rect.height * dpr;
                weightsCtx.scale(dpr, dpr);
            }

            function visualizeWeights() {
                const rect = weightsCanvas.getBoundingClientRect();
                const width = rect.width;
                const height = rect.height;
                const padding = 8;

                weightsCtx.fillStyle = "#fff";
                weightsCtx.fillRect(0, 0, width, height);

                // Collect all weights for global normalization
                const allWeights = [];
                for (let h = 0; h < hiddenUnits; h++) {
                    allWeights.push(...W1[h]);
                }
                for (let i = 0; i < W2.length; i++) {
                    allWeights.push(...W2[i]);
                }
                const min = Math.min(...allWeights);
                const max = Math.max(...allWeights);
                const range = max - min;

                // Total weights: W1 (64 * hiddenUnits) + W2 (4 * hiddenUnits)
                const totalW1 = 64 * hiddenUnits;
                const totalW2 = W2.length * hiddenUnits;
                const totalWeights = totalW1 + totalW2;

                // Layout as a grid with padding
                const availableWidth = width - (padding * 2);
                const availableHeight = height - (padding * 2);
                const cols = Math.ceil(Math.sqrt(totalWeights * (availableWidth / availableHeight)));
                const rows = Math.ceil(totalWeights / cols);
                const cellWidth = availableWidth / cols;
                const cellHeight = availableHeight / rows;

                let weightIdx = 0;

                // Draw W1 weights
                for (let h = 0; h < hiddenUnits; h++) {
                    for (let i = 0; i < 64; i++) {
                        const weight = W1[h][i];
                        const normalized = range > 0 ? (weight - min) / range : 0.5;
                        const intensity = Math.floor(normalized * 255);

                        let r = intensity, g = intensity, b = intensity;

                        // Gradient overlay
                        if (currentGradientsW1[h] && maxGradientNormW1 > 0) {
                            const gradMag = currentGradientsW1[h][i];
                            const normGrad = Math.min(1, gradMag / maxGradientNormW1);
                            r = Math.floor(intensity + (255 - intensity) * normGrad * 0.7);
                            g = Math.floor(intensity + (165 - intensity) * normGrad * 0.7);
                            b = Math.floor(intensity + (0 - intensity) * normGrad * 0.7);
                        }

                        const col = weightIdx % cols;
                        const row = Math.floor(weightIdx / cols);
                        weightsCtx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                        weightsCtx.fillRect(padding + col * cellWidth, padding + row * cellHeight, cellWidth, cellHeight);

                        weightIdx++;
                    }
                }

                // Draw W2 weights
                for (let outClass = 0; outClass < W2.length; outClass++) {
                    for (let h = 0; h < hiddenUnits; h++) {
                        const weight = W2[outClass][h];
                        const normalized = range > 0 ? (weight - min) / range : 0.5;
                        const intensity = Math.floor(normalized * 255);

                        let r = intensity, g = intensity, b = intensity;

                        // Gradient overlay
                        if (
                            currentGradientsW2[outClass] &&
                            maxGradientNormW2 > 0
                        ) {
                            const gradMag = currentGradientsW2[outClass][h];
                            const normGrad = Math.min(1, gradMag / maxGradientNormW2);
                            r = Math.floor(intensity + (255 - intensity) * normGrad * 0.7);
                            g = Math.floor(intensity + (165 - intensity) * normGrad * 0.7);
                            b = Math.floor(intensity + (0 - intensity) * normGrad * 0.7);
                        }

                        const col = weightIdx % cols;
                        const row = Math.floor(weightIdx / cols);
                        weightsCtx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                        weightsCtx.fillRect(padding + col * cellWidth, padding + row * cellHeight, cellWidth, cellHeight);

                        weightIdx++;
                    }
                }

                // Draw weight count in bottom right
                weightsCtx.font = "11px 'Berkeley Mono', monospace";
                weightsCtx.fillStyle = "#000";
                weightsCtx.textAlign = "right";
                weightsCtx.textBaseline = "bottom";
                weightsCtx.fillText(`${totalWeights} weights`, width - padding, height - padding);
            }

            // ============================================
            // LOSS LANDSCAPE VISUALIZATION
            // ============================================
            const lossCanvas = document.getElementById("lossLandscape");
            const lossCtx = lossCanvas.getContext("2d");

            function resizeLossCanvas() {
                const dpr = window.devicePixelRatio || 1;
                lossCanvas.width = 150 * dpr;
                lossCanvas.height = 120 * dpr;
                lossCtx.scale(dpr, dpr);
            }
            resizeLossCanvas();

            function drawLossLandscape() {
                const width = 150;
                const height = 120;

                lossCtx.fillStyle = "#fff";
                lossCtx.fillRect(0, 0, width, height);

                if (trajectoryPoints.length < 2) return;

                // Find bounds for trajectory
                const w1Values = trajectoryPoints.map((p) => p.w1);
                const w2Values = trajectoryPoints.map((p) => p.w2);
                const lossValues = trajectoryPoints.map((p) => p.loss);

                const minW1 = Math.min(...w1Values);
                const maxW1 = Math.max(...w1Values);
                const minW2 = Math.min(...w2Values);
                const maxW2 = Math.max(...w2Values);
                const minLoss = Math.min(...lossValues);
                const maxLoss = Math.max(...lossValues);

                const rangeW1 = maxW1 - minW1 || 1;
                const rangeW2 = maxW2 - minW2 || 1;
                const rangeLoss = maxLoss - minLoss || 1;

                // 3D projection parameters
                const centerX = width / 2;
                const centerY = height * 0.7;
                const scaleXY = Math.min(width, height) * 0.3;
                const scaleZ = -height * 0.4; // Negative to invert Y-axis

                // Project 3D point to 2D (isometric-ish projection)
                function project3D(w1, w2, loss) {
                    const nx = (w1 - minW1) / rangeW1 - 0.5; // -0.5 to 0.5
                    const ny = (w2 - minW2) / rangeW2 - 0.5;
                    const nz = (loss - minLoss) / rangeLoss;

                    // Isometric projection
                    const x = centerX + (nx - ny) * scaleXY;
                    const y = centerY + (nx + ny) * scaleXY * 0.5 + nz * scaleZ;

                    return { x, y };
                }

                // Draw grid for the base plane
                lossCtx.strokeStyle = "#ccc";
                lossCtx.lineWidth = 1;

                for (let i = 0; i <= 10; i++) {
                    const t = i / 10;
                    const w1 = minW1 + rangeW1 * t;
                    const w2_start = minW2;
                    const w2_end = minW2 + rangeW2;

                    const p1 = project3D(w1, w2_start, minLoss);
                    const p2 = project3D(w1, w2_end, minLoss);

                    lossCtx.beginPath();
                    lossCtx.moveTo(p1.x, p1.y);
                    lossCtx.lineTo(p2.x, p2.y);
                    lossCtx.stroke();
                }

                for (let i = 0; i <= 10; i++) {
                    const t = i / 10;
                    const w2 = minW2 + rangeW2 * t;
                    const w1_start = minW1;
                    const w1_end = minW1 + rangeW1;

                    const p1 = project3D(w1_start, w2, minLoss);
                    const p2 = project3D(w1_end, w2, minLoss);

                    lossCtx.beginPath();
                    lossCtx.moveTo(p1.x, p1.y);
                    lossCtx.lineTo(p2.x, p2.y);
                    lossCtx.stroke();
                }

                // Draw trajectory path
                lossCtx.strokeStyle = "#000";
                lossCtx.lineWidth = 2;
                lossCtx.beginPath();

                for (let i = 0; i < trajectoryPoints.length; i++) {
                    const point = trajectoryPoints[i];
                    const { x, y } = project3D(point.w1, point.w2, point.loss);

                    if (i === 0) {
                        lossCtx.moveTo(x, y);
                    } else {
                        lossCtx.lineTo(x, y);
                    }
                }

                lossCtx.stroke();

                // Draw points along trajectory (with fade)
                for (let i = 0; i < trajectoryPoints.length; i++) {
                    const point = trajectoryPoints[i];
                    const { x, y } = project3D(point.w1, point.w2, point.loss);

                    const alpha = (i / trajectoryPoints.length) * 0.6 + 0.4;
                    lossCtx.fillStyle = `rgba(0, 0, 0, ${alpha})`;
                    lossCtx.beginPath();
                    lossCtx.arc(x, y, 2, 0, Math.PI * 2);
                    lossCtx.fill();
                }

                // Draw current position (larger)
                if (trajectoryPoints.length > 0) {
                    const current =
                        trajectoryPoints[trajectoryPoints.length - 1];
                    const { x, y } = project3D(
                        current.w1,
                        current.w2,
                        current.loss,
                    );

                    lossCtx.fillStyle = "#000";
                    lossCtx.beginPath();
                    lossCtx.arc(x, y, 4, 0, Math.PI * 2);
                    lossCtx.fill();

                    lossCtx.strokeStyle = "#fff";
                    lossCtx.lineWidth = 2;
                    lossCtx.stroke();
                }

                // No labels needed for compact view
            }

            function updatePatternStats() {
                const stats = computePatternStats();
                document.getElementById("patternIteration").textContent =
                    patternIteration;
                if (trainingData.length === 0 || W2.length === 0) {
                    document.getElementById("patternLoss").textContent = "—";
                    document.getElementById("patternAccuracy").textContent =
                        "—";
                    document.getElementById("patternStatus").textContent =
                        "SELECT PATTERNS";
                    document.getElementById("patternStatus").style.color =
                        "#555";
                    document.getElementById("patternStatus").style.fontWeight =
                        "normal";
                    return;
                }

                document.getElementById("patternLoss").textContent =
                    stats.loss.toFixed(3);
                document.getElementById("patternAccuracy").textContent =
                    Math.round(stats.accuracy) + "%";

                // Check for convergence
                if (stats.loss < 0.08 && patternRunning) {
                    patternRunning = false;
                    document.getElementById("patternStartBtn").textContent =
                        "START LEARNING";
                    document.getElementById("patternStatus").textContent =
                        "CONVERGED";
                    document.getElementById("patternStatus").style.color =
                        "#000";
                    document.getElementById("patternStatus").style.fontWeight =
                        "bold";
                } else {
                    document.getElementById("patternStatus").textContent =
                        patternRunning ? "ACTIVE" : "PAUSED";
                    document.getElementById("patternStatus").style.color =
                        "#000";
                    document.getElementById("patternStatus").style.fontWeight =
                        "normal";
                }
            }

            function animatePattern(timestamp) {
                if (!patternRunning) return;
                if (trainingData.length === 0 || W2.length === 0) {
                    patternRunning = false;
                    document.getElementById("patternStartBtn").textContent =
                        "START LEARNING";
                    updatePatternStats();
                    return;
                }

                // Initialize lastFrameTime on first frame
                if (lastFrameTime === 0) {
                    lastFrameTime = timestamp;
                    requestAnimationFrame(animatePattern);
                    return;
                }

                // Calculate elapsed time in seconds
                const deltaTime = (timestamp - lastFrameTime) / 1000;
                lastFrameTime = timestamp;

                // Calculate steps to run based on time elapsed
                // Base speed: 100 steps/sec, scaled by trainingSpeed (0 to 1)
                const stepsPerSecond = trainingSpeed * 100;
                stepAccumulator += stepsPerSecond * deltaTime;

                // Execute accumulated steps
                const stepsToRun = Math.floor(stepAccumulator);
                stepAccumulator -= stepsToRun;

                for (let i = 0; i < stepsToRun; i++) {
                    patternSGDStep();
                }

                // Update visualization every frame
                updatePatternStats();
                drawPattern();
                visualizeWeights();
                drawLossLandscape();

                requestAnimationFrame(animatePattern);
            }

            document
                .getElementById("patternStartBtn")
                .addEventListener("click", () => {
                    if (trainingData.length === 0 || W2.length === 0) {
                        updatePatternStats();
                        return;
                    }
                    patternRunning = !patternRunning;
                    const btn = document.getElementById("patternStartBtn");
                    if (patternRunning) {
                        btn.textContent = "PAUSE";
                        lastFrameTime = 0; // Reset timing
                        stepAccumulator = 0;
                        requestAnimationFrame(animatePattern);
                    } else {
                        btn.textContent = "START LEARNING";
                    }
                });

            document
                .getElementById("patternResetBtn")
                .addEventListener("click", () => {
                    patternRunning = false;
                    document.getElementById("patternStartBtn").textContent =
                        "START LEARNING";
                    lastFrameTime = 0;
                    stepAccumulator = 0;
                    initPatternNetwork();
                    updatePatternStats();
                    drawPattern();
                    visualizeWeights();
                    drawLossLandscape();
                });

            document
                .getElementById("patternLearningRate")
                .addEventListener("input", (e) => {
                    patternLearningRate = parseFloat(e.target.value);
                    document.getElementById(
                        "patternLearningRateValue",
                    ).textContent = patternLearningRate.toFixed(3);
                });

            document
                .getElementById("trainingSpeed")
                .addEventListener("input", (e) => {
                    trainingSpeed = parseFloat(e.target.value);
                    // Show up to 3 decimal places, removing trailing zeros
                    const formatted = parseFloat(
                        trainingSpeed.toFixed(3),
                    ).toString();
                    document.getElementById("trainingSpeedValue").textContent =
                        formatted;
                });

            document
                .getElementById("hiddenUnits")
                .addEventListener("input", (e) => {
                    const newHiddenUnits = parseInt(e.target.value);
                    if (newHiddenUnits !== hiddenUnits) {
                        hiddenUnits = newHiddenUnits;
                        document.getElementById(
                            "hiddenUnitsValue",
                        ).textContent = hiddenUnits;
                        patternRunning = false;
                        document.getElementById("patternStartBtn").textContent =
                            "START LEARNING";
                        lastFrameTime = 0;
                        stepAccumulator = 0;
                        initPatternNetwork();
                        updatePatternStats();
                        drawPattern();
                        visualizeWeights();
                        updateNetworkDiagram();
                        drawLossLandscape();
                    }
                });

            regenerateDatasetBtn.addEventListener("click", () => {
                regenerateDataset();
            });

            // ============================================
            // PIXEL SKETCHPAD UTILITIES
            // ============================================
            function createPixelSketchpad(container, options = {}) {
                let changeHandler = options.onChange || null;
                let state = options.initialState
                    ? options.initialState.slice()
                    : new Array(GRID_SIZE * GRID_SIZE).fill(0);

                container.innerHTML = "";
                const pixels = [];
                for (let i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
                    const pixel = document.createElement("div");
                    pixel.className = "draw-pixel";
                    pixel.dataset.index = i;
                    container.appendChild(pixel);
                    pixels.push(pixel);
                }

                function updatePixel(index) {
                    if (state[index] === 1) {
                        pixels[index].classList.add("active");
                    } else {
                        pixels[index].classList.remove("active");
                    }
                }

                function syncAll() {
                    for (let i = 0; i < state.length; i++) {
                        updatePixel(i);
                    }
                }

                function emitChange() {
                    if (typeof changeHandler === "function") {
                        changeHandler(state.slice());
                    }
                }

                let isDrawing = false;
                let drawMode = 1;

                function handleIndexChange(index, value) {
                    const nextValue =
                        typeof value === "number"
                            ? value
                            : state[index] === 1
                            ? 0
                            : 1;
                    if (state[index] === nextValue) {
                        return;
                    }
                    state[index] = nextValue;
                    updatePixel(index);
                    emitChange();
                }

                container.addEventListener("mousedown", (event) => {
                    if (event.target.classList.contains("draw-pixel")) {
                        const index = parseInt(event.target.dataset.index, 10);
                        isDrawing = true;
                        drawMode = state[index] === 1 ? 0 : 1;
                        handleIndexChange(index, drawMode);
                    }
                });

                container.addEventListener("mouseover", (event) => {
                    if (isDrawing && event.target.classList.contains("draw-pixel")) {
                        const index = parseInt(event.target.dataset.index, 10);
                        if (state[index] !== drawMode) {
                            handleIndexChange(index, drawMode);
                        }
                    }
                });

                document.addEventListener("mouseup", () => {
                    isDrawing = false;
                });

                container.addEventListener("touchstart", (event) => {
                    event.preventDefault();
                    const touch = event.touches[0];
                    const element = document.elementFromPoint(
                        touch.clientX,
                        touch.clientY,
                    );
                    if (element && element.classList.contains("draw-pixel")) {
                        const index = parseInt(element.dataset.index, 10);
                        isDrawing = true;
                        drawMode = state[index] === 1 ? 0 : 1;
                        handleIndexChange(index, drawMode);
                    }
                });

                container.addEventListener("touchmove", (event) => {
                    event.preventDefault();
                    if (!isDrawing) return;
                    const touch = event.touches[0];
                    const element = document.elementFromPoint(
                        touch.clientX,
                        touch.clientY,
                    );
                    if (element && element.classList.contains("draw-pixel")) {
                        const index = parseInt(element.dataset.index, 10);
                        if (state[index] !== drawMode) {
                            handleIndexChange(index, drawMode);
                        }
                    }
                });

                document.addEventListener("touchend", () => {
                    isDrawing = false;
                });

                syncAll();

                return {
                    getState() {
                        return state.slice();
                    },
                    setState(newState) {
                        state = newState.slice();
                        syncAll();
                        emitChange();
                    },
                    clear() {
                        let changed = false;
                        for (let i = 0; i < state.length; i++) {
                            if (state[i] !== 0) {
                                state[i] = 0;
                                changed = true;
                            }
                        }
                        if (changed) {
                            syncAll();
                            emitChange();
                        } else {
                            syncAll();
                        }
                    },
                    setOnChange(handler) {
                        changeHandler = handler;
                    },
                };
            }

            function classifyDrawing() {
                if (!drawSketchpad) {
                    return;
                }

                const drawState = drawSketchpad.getState();

                if (drawState.every((v) => v === 0)) {
                    document.getElementById("drawPrediction").textContent = "—";
                    document.getElementById("drawConfidence").textContent = "—";
                    document.getElementById("activationsViz").innerHTML = "";
                    document.getElementById("outputActivationsViz").innerHTML = "";
                    return;
                }

                if (classNames.length === 0 || W2.length === 0) {
                    document.getElementById("drawPrediction").textContent = "—";
                    document.getElementById("drawConfidence").textContent = "—";
                    document.getElementById("activationsViz").innerHTML = "";
                    const outputContainer = document.getElementById(
                        "outputActivationsViz",
                    );
                    outputContainer.innerHTML =
                        "<div style=\"font-size:11px;color:#555;\">Add pattern families to enable classification.</div>";
                    return;
                }

                const { output, hidden } = forwardPass(drawState);
                let predicted = -1;
                let maxVal = -Infinity;
                for (let i = 0; i < output.length; i++) {
                    if (output[i] > maxVal) {
                        maxVal = output[i];
                        predicted = i;
                    }
                }
                const confidence =
                    predicted >= 0 ? (output[predicted] * 100).toFixed(1) : "0.0";

                document.getElementById("drawPrediction").textContent =
                    predicted >= 0 && classNames[predicted]
                        ? classNames[predicted]
                        : "—";
                document.getElementById("drawConfidence").textContent =
                    predicted >= 0 ? `${confidence}%` : "—";

                const activationsContainer = document.getElementById("activationsViz");
                activationsContainer.innerHTML = "";

                const maxActivation = Math.max(...hidden);

                for (let i = 0; i < hidden.length; i++) {
                    const activation = hidden[i];
                    const normalized = maxActivation > 0 ? activation / maxActivation : 0;
                    const intensity = Math.floor(normalized * 255);

                    const cell = document.createElement("div");
                    cell.style.width = "35px";
                    cell.style.height = "35px";
                    cell.style.background = `rgb(${intensity}, ${intensity}, ${intensity})`;
                    cell.style.border = "2px solid #000";
                    cell.style.display = "flex";
                    cell.style.alignItems = "center";
                    cell.style.justifyContent = "center";
                    cell.style.fontSize = "10px";
                    cell.style.fontWeight = "bold";
                    cell.style.color = normalized > 0.5 ? "#000" : "#fff";
                    cell.textContent = activation.toFixed(1);

                    activationsContainer.appendChild(cell);
                }

                const outputContainer = document.getElementById("outputActivationsViz");
                outputContainer.innerHTML = "";

                const maxOutput = Math.max(...output);

                for (let i = 0; i < output.length; i++) {
                    const activation = output[i];
                    const normalized = maxOutput > 0 ? activation / maxOutput : 0;
                    const intensity = Math.floor(normalized * 255);

                    const cell = document.createElement("div");
                    cell.style.width = "60px";
                    cell.style.height = "35px";
                    cell.style.background = `rgb(${intensity}, ${intensity}, ${intensity})`;
                    cell.style.border = i === predicted ? "3px solid #000" : "2px solid #000";
                    cell.style.display = "flex";
                    cell.style.alignItems = "center";
                    cell.style.justifyContent = "center";
                    cell.style.fontSize = "9px";
                    cell.style.fontWeight = "bold";
                    cell.style.color = normalized > 0.5 ? "#000" : "#fff";
                    cell.style.flexDirection = "column";
                    cell.style.gap = "2px";

                    const label = document.createElement("div");
                    label.style.fontSize = "8px";
                    label.textContent = (classNames[i] || "?").toUpperCase();

                    const value = document.createElement("div");
                    value.textContent = (activation * 100).toFixed(0) + "%";

                    cell.appendChild(label);
                    cell.appendChild(value);

                    outputContainer.appendChild(cell);
                }
            }

            // ============================================
            // CUSTOM PATTERN BUILDER
            // ============================================
            const customPatternCanvasEl = document.getElementById(
                "customPatternCanvas",
            );
            const customPatternAddBtn = document.getElementById("customPatternAdd");
            const customPatternClearBtn = document.getElementById(
                "customPatternClear",
            );
            const customPatternCreateBtn = document.getElementById(
                "customPatternCreate",
            );
            const customPatternResetBtn = document.getElementById(
                "customPatternReset",
            );
            const customPatternNameInput = document.getElementById(
                "customPatternName",
            );
            const customPatternSamplesInput = document.getElementById(
                "customPatternSamples",
            );
            const customPatternSamplesValue = document.getElementById(
                "customPatternSamplesValue",
            );
            const customPatternNoiseInput = document.getElementById(
                "customPatternNoise",
            );
            const customPatternNoiseValue = document.getElementById(
                "customPatternNoiseValue",
            );
            const customPatternVariantsEl = document.getElementById(
                "customPatternVariants",
            );
            const customPatternMessageEl = document.getElementById(
                "customPatternMessage",
            );
            let customPatternPrototypes = [];

            customSketchpad = createPixelSketchpad(customPatternCanvasEl);

            function setCustomBuilderMessage(text, type = "") {
                customPatternMessageEl.textContent = text;
                customPatternMessageEl.classList.remove("error", "success");
                if (type) {
                    customPatternMessageEl.classList.add(type);
                }
            }

            function renderCustomPatternVariants() {
                customPatternVariantsEl.innerHTML = "";
                if (customPatternPrototypes.length === 0) {
                    const placeholder = document.createElement("div");
                    placeholder.style.fontSize = "11px";
                    placeholder.style.color = "#555";
                    placeholder.textContent =
                        "No variations yet. Sketch a pattern and add it.";
                    customPatternVariantsEl.appendChild(placeholder);
                    return;
                }

                customPatternPrototypes.forEach((pattern, index) => {
                    const variant = document.createElement("div");
                    variant.className = "custom-variant";

                    const preview = document.createElement("div");
                    preview.className = "pattern-preview-grid small";
                    renderPatternPreview(preview, pattern, pattern);
                    variant.appendChild(preview);

                    const caption = document.createElement("div");
                    caption.style.fontSize = "10px";
                    caption.style.color = "#000";
                    caption.textContent = `Variation ${index + 1}`;
                    variant.appendChild(caption);

                    const removeBtn = document.createElement("button");
                    removeBtn.type = "button";
                    removeBtn.className = "secondary tiny";
                    removeBtn.textContent = "Remove";
                    removeBtn.addEventListener("click", () => {
                        customPatternPrototypes.splice(index, 1);
                        renderCustomPatternVariants();
                        setCustomBuilderMessage("Removed variation.", "");
                    });
                    variant.appendChild(removeBtn);

                    customPatternVariantsEl.appendChild(variant);
                });
            }

            function resetCustomPatternBuilder() {
                customPatternPrototypes = [];
                if (customSketchpad) {
                    customSketchpad.clear();
                }
                customPatternNameInput.value = "";
                customPatternSamplesInput.value = "60";
                customPatternSamplesValue.textContent = "60";
                customPatternNoiseInput.value = "0.18";
                customPatternNoiseValue.textContent = "18";
                renderCustomPatternVariants();
                setCustomBuilderMessage("Start by sketching a pattern above.", "");
            }

            customPatternSamplesInput.addEventListener("input", () => {
                customPatternSamplesValue.textContent =
                    customPatternSamplesInput.value;
            });

            customPatternNoiseInput.addEventListener("input", () => {
                const percent = Math.round(
                    parseFloat(customPatternNoiseInput.value) * 100,
                );
                customPatternNoiseValue.textContent = percent;
            });

            customPatternClearBtn.addEventListener("click", () => {
                if (customSketchpad) {
                    customSketchpad.clear();
                }
                setCustomBuilderMessage("Cleared sketch.", "");
            });

            customPatternAddBtn.addEventListener("click", () => {
                if (!customSketchpad) return;
                const pattern = customSketchpad.getState();
                const hasInk = pattern.some((value) => value === 1);
                if (!hasInk) {
                    setCustomBuilderMessage(
                        "Draw something before adding a variation.",
                        "error",
                    );
                    return;
                }
                customPatternPrototypes.push(pattern);
                renderCustomPatternVariants();
                setCustomBuilderMessage("Captured variation.", "success");
                customSketchpad.clear();
            });

            customPatternCreateBtn.addEventListener("click", () => {
                const name = customPatternNameInput.value.trim();
                if (!name) {
                    setCustomBuilderMessage(
                        "Give your pattern type a name.",
                        "error",
                    );
                    return;
                }

                if (customPatternPrototypes.length === 0) {
                    setCustomBuilderMessage(
                        "Add at least one variation before creating a pattern type.",
                        "error",
                    );
                    return;
                }

                const samples = parseInt(customPatternSamplesInput.value, 10);
                const noise = parseFloat(customPatternNoiseInput.value);

                const family = registerCustomPatternFamily({
                    name,
                    prototypes: customPatternPrototypes,
                    samples,
                    noise,
                });

                if (!family) {
                    setCustomBuilderMessage(
                        "Couldn't create pattern family. Try again.",
                        "error",
                    );
                    return;
                }

                buildPatternLibraryUI();
                scheduleDatasetUpdate(true);
                resetCustomPatternBuilder();
                setCustomBuilderMessage(
                    `Created “${family.name}” with ${family.prototypes.length} variations.`,
                    "success",
                );
            });

            customPatternResetBtn.addEventListener("click", () => {
                resetCustomPatternBuilder();
            });

            // ============================================
            // DRAWING INTERFACE
            // ============================================
            const drawCanvasContainer = document.getElementById("drawCanvas");
            drawSketchpad = createPixelSketchpad(drawCanvasContainer, {
                onChange: () => {
                    classifyDrawing();
                },
            });

            document
                .getElementById("clearDrawing")
                .addEventListener("click", () => {
                    if (drawSketchpad) {
                        drawSketchpad.clear();
                    }
                });

            // Initialize everything
            buildPatternLibraryUI();
            resetCustomPatternBuilder();
            regenerateDataset();
            classifyDrawing();
        </script>
    </body>
</html>
